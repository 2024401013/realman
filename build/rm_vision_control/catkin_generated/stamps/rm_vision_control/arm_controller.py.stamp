#!/usr/bin/env python

# src/rm_vision_control/scripts/arm_controller.py
import rospy
import numpy as np
from geometry_msgs.msg import Pose, Quaternion
from rm_msgs.msg import MoveJ, MoveJ_P, MoveL, Plan_State
from std_msgs.msg import Int32, Float32

class ArmController:
    def __init__(self):
        # ==== 需要根据实际情况修改的配置 ====
        # 机械臂初始位置（零点）
        self.home_pose = Pose()
        self.home_pose.position.x = 0.0     # 请根据实际情况修改
        self.home_pose.position.y = 0.0      # 请根据实际情况修改  
        self.home_pose.position.z = 0.85      # 请根据实际情况修改
        self.home_pose.orientation.x = 0
        self.home_pose.orientation.y = 0
        self.home_pose.orientation.z = 1.0
        self.home_pose.orientation.w = 0

        horizontal_orientation = self.euler_to_quaternion(roll=np.pi/2, pitch=0, yaw=0)
        
        # 观测姿态pose1和pose2 
        self.pose1 = Pose()
        self.pose1.position.x = - 0.3          # 请根据实际情况修改
        self.pose1.position.y = 0.0          # 请根据实际情况修改
        self.pose1.position.z = 0.65          # 请根据实际情况修改
        self.pose1.orientation.x = -0.707
        self.pose1.orientation.y = 0
        self.pose1.orientation.z = 0.707
        self.pose1.orientation.w = 0
        
        self.pose2 = Pose()
        self.pose2.position.x = self.pose1.position.x
        self.pose2.position.y = self.pose1.position.y
        self.pose2.position.z = self.pose1.position.z - 0.3  
        self.pose2.orientation = self.pose1.orientation

        self.detect_pose = Pose()
        self.detect_pose.position.x = - 0.3          # 请根据实际情况修改
        self.detect_pose.position.y = 0.0          # 请根据实际情况修改
        self.detect_pose.position.z = 0.45          # 请根据实际情况修改
        self.detect_pose.orientation.x = -0.707
        self.detect_pose.orientation.y = 0
        self.detect_pose.orientation.z = 0.707
        self.detect_pose.orientation.w = 0
        # =================================
        
        # 发布者
        self.movej_pub = rospy.Publisher('/rm_driver/MoveJ_Cmd', MoveJ, queue_size=10)
        self.movej_p_pub = rospy.Publisher('/rm_driver/MoveJ_P_Cmd', MoveJ_P, queue_size=10)
        self.movel_pub = rospy.Publisher('/rm_driver/MoveL_Cmd', MoveL, queue_size=10)
        self.car_speed_pub = rospy.Publisher('/car_speed', Float32, queue_size=10)
        self.arm_state_pub = rospy.Publisher('/arm_state', Int32, queue_size=10)
        self.arm_state_timer = None  # 用于定时发布

        # 订阅者
        rospy.Subscriber('/rm_driver/Plan_State', Plan_State, self.plan_state_callback)
        
        # 状态变量
        self.plan_completed = False
        self.last_plan_result = False
        self.arm_state = 0  # 0-未工作, 1-工作中

        # 启动定时发布
        self.start_arm_state_publishing()
        
        rospy.loginfo("ArmController initialized")
    
    def start_arm_state_publishing(self):
        """以1Hz频率发布arm_state"""
        if self.arm_state_timer is not None:
            self.arm_state_timer.shutdown()
        
        def publish_state(event):
            msg = Int32()
            msg.data = self.arm_state
            self.arm_state_pub.publish(msg)
        
        self.arm_state_timer = rospy.Timer(rospy.Duration(1.0), publish_state)

    def set_arm_state(self, state):
        """设置机械臂状态"""
        self.arm_state = state
        rospy.loginfo(f"Arm state changed to: {state}")

    def plan_state_callback(self, msg):
        """规划状态回调"""
        self.plan_completed = True
        self.last_plan_result = msg.state
    
    def wait_for_completion(self, timeout=10.0):
        """等待规划完成"""
        start_time = rospy.Time.now()
        while not self.plan_completed and (rospy.Time.now() - start_time).to_sec() < timeout:
            rospy.sleep(0.1)
        
        result = self.last_plan_result
        self.plan_completed = False
        return result
    
    def go_home(self, speed=0.5):
        """回到初始位置"""
        return self.move_to_pose_jp(self.home_pose, speed)
    
    def move_to_pose_jp(self, pose, speed=0.5):
        """通过MoveJ_P移动到位姿（关节空间规划）"""
        movej_p_cmd = MoveJ_P()
        movej_p_cmd.Pose = pose
        movej_p_cmd.speed = speed
        movej_p_cmd.trajectory_connect = 0
        
        self.plan_completed = False
        self.movej_p_pub.publish(movej_p_cmd)
        
        return self.wait_for_completion()
    
    def move_to_pose_line(self, pose, speed=0.5):
        """通过MoveL移动到位姿（直线运动）"""
        movel_cmd = MoveL()
        movel_cmd.Pose = pose
        movel_cmd.speed = speed
        movel_cmd.trajectory_connect = 0
        
        self.plan_completed = False
        self.movel_pub.publish(movel_cmd)
        
        return self.wait_for_completion()
    
    def move_joints(self, joints, speed=0.5):
        """通过MoveJ移动到关节角度"""
        movej_cmd = MoveJ()
        movej_cmd.joint = joints
        movej_cmd.speed = speed
        movej_cmd.trajectory_connect = 0
        
        self.plan_completed = False
        self.movej_pub.publish(movej_cmd)
        
        return self.wait_for_completion()
    
    def set_car_speed(self, speed):
        """控制小车速度"""
        speed_msg = Float32()
        speed_msg.data = speed
        self.car_speed_pub.publish(speed_msg)
    
    def euler_to_quaternion(self, roll, pitch, yaw):
        """欧拉角转四元数"""
        qx = np.sin(roll/2) * np.cos(pitch/2) * np.cos(yaw/2) - np.cos(roll/2) * np.sin(pitch/2) * np.sin(yaw/2)
        qy = np.cos(roll/2) * np.sin(pitch/2) * np.cos(yaw/2) + np.sin(roll/2) * np.cos(pitch/2) * np.sin(yaw/2)
        qz = np.cos(roll/2) * np.cos(pitch/2) * np.sin(yaw/2) - np.sin(roll/2) * np.sin(pitch/2) * np.cos(yaw/2)
        qw = np.cos(roll/2) * np.cos(pitch/2) * np.cos(yaw/2) + np.sin(roll/2) * np.sin(pitch/2) * np.sin(yaw/2)
        
        quat = Quaternion()
        quat.x = qx
        quat.y = qy
        quat.z = qz
        quat.w = qw
        return quat
    
    def create_pose(self, x, y, z, orientation=None):
        """创建位姿"""
        pose = Pose()
        pose.position.x = x
        pose.position.y = y
        pose.position.z = z
        if orientation is None:
            pose.orientation = self.home_pose.orientation
        else:
            pose.orientation = orientation
        return pose